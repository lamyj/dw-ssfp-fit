#!/usr/bin/env python3

import argparse
import os
import socket
import subprocess
import sys
import tempfile

import nibabel
import numpy

def main():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    
    parser.add_argument("image", help="Path to the singularity image")
    parser.add_argument("scheme", help="Path to the acquisition scheme")
    parser.add_argument("DW_SSFP", help="Path to the DW-SSFP image")
    parser.add_argument(
        "T1_map", help="Path to the T1 map image, must be in seconds")
    parser.add_argument(
        "T2_map", help="Path to the T2 map image, must be in seconds")
    parser.add_argument("B1_map", help="Path to the relative B1 map image")
    parser.add_argument("mask", help="Path to the mask image")
    parser.add_argument("D", help="Path to the output diffusion tensor image")
    
    parser.add_argument(
        "--reference", "-r", type=int, default=0,
        help="Number of non-diffusion-weighted (or low-diffusion-weighted) "
            "acquisition")
    parser.add_argument(
        "--population", "-p", type=int, default=10,
        help="Number of individuals")
    parser.add_argument(
        "--generations", "-g", type=int, default=1,
        help="Number of generations")
    arguments = parser.parse_args()
    
    try:
        task_min, task_max, task_step = [
            int(os.environ["SLURM_ARRAY_TASK_{}".format(x)])
            for x in ["MIN", "MAX", "STEP"]]
    except KeyError:
        parser.error(
            "Missing environment variables: "
            "this must be run as a Slurm task array")
    if task_min != 0 or task_step != 1:
        parser.error("Task array must be of the form 0-N")
    task_count = 1+(task_max-task_min)
    
    task_id = int(os.environ["SLURM_ARRAY_TASK_ID"])
    print("Task {}/{} on {}".format(task_id, task_count, socket.gethostname()))
    
    with tempfile.TemporaryDirectory() as directory:
        T1_map = nibabel.load(arguments.T1_map)
        T2_map = nibabel.load(arguments.T2_map)
        B1_map = nibabel.load(arguments.B1_map)
        mask = nibabel.load(arguments.mask)
        
        mask_data = (
            (numpy.asarray(mask.dataobj) != 0)
            & (T1_map.get_fdata() > 0) & (T1_map.get_fdata() < 2) 
            & (T2_map.get_fdata() > 0) & (T2_map.get_fdata() < 1) 
            & (B1_map.get_fdata() > 0.5) & (B1_map.get_fdata() < 1.5))
        
        mask_indices = numpy.array(mask_data.nonzero())
        sub_mask_size, remainder = divmod(mask_indices.shape[1], task_count)
        sub_mask_counts = numpy.array(task_count*[sub_mask_size])
        sub_mask_counts[:remainder] += 1
        sub_mask_offsets = numpy.hstack([[0], sub_mask_counts[:-1].cumsum()])
        
        sub_mask_data = numpy.zeros_like(mask_data, int)
        task_indices = mask_indices[
            :,
            sub_mask_offsets[task_id]:sub_mask_offsets[task_id]+sub_mask_counts[task_id]]
        sub_mask_data[tuple(task_indices.tolist())] = 1
        
        sub_mask_path = os.path.join(
            directory, "mask_{}.nii.gz".format(task_id))
        nibabel.save(
            nibabel.Nifti1Image(sub_mask_data, mask.affine), sub_mask_path)
        
        sub_D_path = os.path.join(
            os.path.dirname(arguments.D),
            "{}_{}.{}".format(
                os.path.basename(arguments.D).split(".", 1)[0],
                task_id,
                os.path.basename(arguments.D).split(".", 1)[1]))
        
        subprocess.check_call([
            "mpirun",
            "singularity", "exec", arguments.image,
            "python3", "fit.py", 
            "-r", str(arguments.reference),
            "-p", str(arguments.population), "-g", str(arguments.generations),
            *[
                getattr(arguments, x) for x in [
                    "scheme", "DW_SSFP", "T1_map", "T2_map", "B1_map"]],
            sub_mask_path, sub_D_path
        ])

if __name__ == "__main__":
    sys.exit(main())
